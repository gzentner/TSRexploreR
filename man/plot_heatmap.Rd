% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/heatmaps.R
\name{plot_heatmap}
\alias{plot_heatmap}
\title{Plot Heatmap}
\usage{
plot_heatmap(
  experiment,
  samples = "all",
  data_type = c("tss", "tsr"),
  upstream = 1000,
  downstream = 1000,
  threshold = NULL,
  use_normalized = FALSE,
  dominant = FALSE,
  remove_antisense = TRUE,
  rasterize = FALSE,
  raster_dpi = 150,
  max_value = NULL,
  low_color = "white",
  high_color = "blue",
  log2_transform = TRUE,
  x_axis_breaks = 100,
  ncol = 3,
  filtering = NULL,
  ordering = score,
  order_descending = TRUE,
  order_fun = sum,
  order_samples = NULL,
  quantiling = NULL,
  quantile_fun = sum,
  n_quantiles = 5,
  quantile_samples = NULL,
  split_by = NULL,
  diff_heatmap_list = NULL,
  ...
)
}
\arguments{
\item{experiment}{TSRexploreR object.}

\item{samples}{A vector of sample names to analyze.}

\item{data_type}{Plot TSS ('tss') or TSR ('tsr') scores.}

\item{upstream}{Bases upstream to consider}

\item{downstream}{bases downstream to consider}

\item{threshold}{TSSs or TSRs with a score below this value will not be considered.}

\item{use_normalized}{Whether to use the normalized (TRUE) or raw (FALSE) counts.}

\item{dominant}{If TRUE, will only consider the highest-scoring TSS per gene, transcript, or TSR or 
highest-scoring TSR per gene or transcript.}

\item{remove_antisense}{Remove antisense reads.}

\item{rasterize}{Rasterize a ggplot.}

\item{raster_dpi}{If rasterization is set, this controls the rasterization DPI.}

\item{max_value}{Truncate heatmap scale at this value.}

\item{low_color}{Color for minimum value.}

\item{high_color}{Color for maximum value.}

\item{log2_transform}{Log2 + 1 transform values for plotting.}

\item{x_axis_breaks}{The distance breaks to show values on the x-axis.}

\item{ncol}{Integer specifying the number of columns to arrange multiple plots.}

\item{filtering}{Logical statement by which to filter data.}

\item{ordering}{Symbol/name specifying the column by which to order.}

\item{order_descending}{Whether to order in descending (TRUE) order.}

\item{order_fun}{Function to aggregate variable by before ordering.}

\item{order_samples}{Samples that are used to calculate ordering.}

\item{quantiling}{Character specifying column by which to quantile..}

\item{quantile_fun}{Functiont o aggregate variable by before quantiling.}

\item{n_quantiles}{Number of quantiles.}

\item{quantile_samples}{Samples to use for quantiling.}

\item{split_by}{Named list with split group as name and vector of genes,
or data.frame with columns 'feature' and 'split_group'.}

\item{diff_heatmap_list}{Named list if sample pairs.
The name will be the comparison name,}

\item{...}{Additional arguments passed to Heatmap}
}
\value{
ggplot2 object of TSS or TSR heatmap
}
\description{
Plot heatmap from count matrix generated by tss_heatmap_matrix or tsr_heatmap_matrix
}
\details{
This plotting function generates a ggplot2 heatmap of TSS or TSR signal
  surrounding the annotated TSSs of genes or transcripts.
Whether genes or transcripts are used depends on the feature type chosen
  when annotating the TSSs with the 'annotate_features' function. 

The region around the annotated TSS used for plotting is controlled by
  'upstream' and 'downstream', which should be positive integers.

A set of arguments to control data structure for plotting are included.
'use_normalized' will use the normalized scores as opposed to raw read counts.
'threshold' definites the minimum number of reads a TSS or TSR
 must have to be considered.
'dominant' specifies whether only the dominant TSS or TSR is considered 
  from the 'mark_dominant' function.
For TSSs this can be either dominant per TSR or gene, and for TSRs
  it is just the dominant TSR per gene.

A set of arguments for data conditions are supplied seperatly from
  the 'conditionals' function used in many other core functions.
This is because each row (feature) can have multiple TSSs or TSRs,
  which is unique to this type of plot.
'filtering' can be supplied with a logical statement to filter TSSs and TSRs
  by the given condition(s).
'ordering' can be supplied with a symbol/name of the variable to order by,
  and 'order_descending' controls ordering direction.
'order_fun' is the function used to aggregate the variable score for each row/feature,
  and 'order_sample' controls the samples used to order from these aggregated variables.
'quantiling' is a character specifying the numeric variable to quantile by,
  and 'n_quantiles' controls the number of quantiles to split the data into.
Just as with ordering, 'quantiles_fun' is the function to aggregate the numeric
  variable by per feature/row, and 'quantile_samples' are the samples used to
  determine the order.
Finally, 'split_by' can be given either a two column data.frame ('feature' and 'split_group'),
  or a named list, where the names are the split category and the list contents are
  a vector of genes.

An option to rasterize the heatmaps using ggrastr is provided with the 'rasterize' argument,
  and the DPI (resolution) is controlled by 'raster_dpi'.

If diff_heatmap_list is given, the heatmaps will represent the subtracted
  score between the sample pairs provided in the list.
If this argument is given the only data conditionals that will work are ordering related.
}
\examples{
data(TSSs_reduced)
annotation <- system.file("extdata", "S288C_Annotation.gtf", package="TSRexploreR")

exp <- TSSs_reduced \%>\%
  tsr_explorer(genome_annotation=annotation) \%>\%
  format_counts(data_type="tss") \%>\%
  annotate_features(data_type="tss")

p <- plot_heatmap(exp, data_type="tss")

}
\seealso{
\code{\link{annotate_features}} to annotate the TSSs or TSRs.
}
